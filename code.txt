#include <bits/stdc++.h>
using namespace std;

// ======== DSU for Kruskal ========
class DSU {
public:
    vector<int> parent, rank;
    DSU(int n) {
        parent.resize(n);
        rank.assign(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    int find_up(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find_up(parent[x]);
    }
    void union_by_rank(int a, int b) {
        a = find_up(a); b = find_up(b);
        if (a == b) return;
        if (rank[a] < rank[b]) swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b]) rank[a]++;
    }
};

// ======== Approach 1: Max-Heap Dijkstra ========
pair<int,vector<int>> maxHeapDijkstra(vector<tuple<int,int,int>> edges, int n, int src, int target) {
    vector<vector<pair<int,int>>> adj(n);
    for (auto &[u,v,c] : edges) {
        adj[u].push_back({v,c});
        adj[v].push_back({u,c});
    }

    vector<int> best(n, -1), parent(n, -1);
    priority_queue<pair<int,int>> pq; // {capacity, node}

    best[src] = INT_MAX;
    pq.push({INT_MAX, src});

    while (!pq.empty()) {
        auto [cap, node] = pq.top();
        pq.pop();
        if (node == target) {
            vector<int> route;
            for (int cur = target; cur != -1; cur = parent[cur])
                route.push_back(cur);
            reverse(route.begin(), route.end());
            return {cap, route};
        }
        for (auto &[nei, edge_cap] : adj[node]) {
            int new_cap = min(cap, edge_cap);
            if (new_cap > best[nei]) {
                best[nei] = new_cap;
                parent[nei] = node;
                pq.push({new_cap, nei});
            }
        }
    }
    return {0, {}};
}

// ======== Approach 2: Reverse Kruskal + DSU ========
pair<int,vector<int>> reverseKruskal(vector<tuple<int,int,int>> edges, int n, int src, int target) {
    sort(edges.begin(), edges.end(), [](auto &a, auto &b) {
        return get<2>(a) > get<2>(b);
    });

    DSU ds(n);
    int best = 0;

    for (auto &[u,v,cap] : edges) {
        ds.union_by_rank(u,v);
        if (ds.find_up(src) == ds.find_up(target)) {
            best = cap;
            break;
        }
    }

    // Build graph with edges >= best
    vector<vector<int>> adj(n);
    for (auto &[u,v,c] : edges) {
        if (c >= best) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
    }

    // BFS for route
    vector<int> parent(n, -1);
    queue<int> q;
    q.push(src);
    parent[src] = -2;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        if (node == target) break;
        for (int nei : adj[node]) {
            if (parent[nei] == -1) {
                parent[nei] = node;
                q.push(nei);
            }
        }
    }

    vector<int> route;
    for (int cur = target; cur != -2; cur = parent[cur])
        route.push_back(cur);
    reverse(route.begin(), route.end());

    return {best, route};
}

// ======== Helper for Binary Search ========
bool canTravel(vector<tuple<int,int,int>> &edges, int n, int src, int target, int cap) {
    vector<vector<int>> adj(n);
    for (auto &[u,v,c] : edges) {
        if (c >= cap) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
    }
    vector<int> vis(n, 0);
    queue<int> q;
    q.push(src);
    vis[src] = 1;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        if (node == target) return true;
        for (int nei : adj[node]) {
            if (!vis[nei]) {
                vis[nei] = 1;
                q.push(nei);
            }
        }
    }
    return false;
}

// ======== Approach 3: Binary Search + BFS ========
pair<int,vector<int>> binarySearchBFS(vector<tuple<int,int,int>> edges, int n, int src, int target) {
    unordered_set<int> st;
    for (auto &[u,v,c] : edges) st.insert(c);
    vector<int> caps(st.begin(), st.end());
    sort(caps.begin(), caps.end());

    int lo = 0, hi = (int)caps.size()-1;
    int best_cap = caps[0];
    while (lo <= hi) {
        int mid = (lo + hi) / 2;
        if (canTravel(edges, n, src, target, caps[mid])) {
            best_cap = caps[mid];
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }

    // BFS to build route
    vector<vector<int>> adj(n);
    for (auto &[u,v,c] : edges) {
        if (c >= best_cap) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
    }
    vector<int> parent(n, -1);
    queue<int> q;
    q.push(src);
    parent[src] = -2;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        if (node == target) break;
        for (int nei : adj[node]) {
            if (parent[nei] == -1) {
                parent[nei] = node;
                q.push(nei);
            }
        }
    }
    vector<int> route;
    for (int cur = target; cur != -2; cur = parent[cur])
        route.push_back(cur);
    reverse(route.begin(), route.end());

    return {best_cap, route};
}

// ======== MAIN ========
int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        vector<tuple<int,int,int>> edges(m);
        for (int i=0; i<m; i++) {
            int u,v,c;
            cin >> u >> v >> c;
            edges[i] = {u,v,c};
        }
        int s, t;
        cin >> s >> t;

        auto [cap1, path1] = maxHeapDijkstra(edges, n, s, t);
        auto [cap2, path2] = reverseKruskal(edges, n, s, t);
        auto [cap3, path3] = binarySearchBFS(edges, n, s, t);

        cout << "Max-Heap Dijkstra: " << cap1 << " Path: ";
        for (int x : path1) cout << x << " ";
        cout << "\n";

        cout << "Reverse Kruskal DSU: " << cap2 << " Path: ";
        for (int x : path2) cout << x << " ";
        cout << "\n";

        cout << "Binary Search BFS: " << cap3 << " Path: ";
        for (int x : path3) cout << x << " ";
        cout << "\n";
    }
}
